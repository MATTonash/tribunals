import { getDocument, GlobalWorkerOptions } from "pdfjs-dist/legacy/build/pdf";
import pdfList from '/static/data/pdfList.json'
import expList from '/static/data/experiment.json'
import { TextItem } from "pdfjs-dist/types/display/api";


// generate the content by the page number
async function getItems(src: string, pg: number) {
  if (typeof workerSrc === "string") {
    GlobalWorkerOptions.workerSrc = workerSrc
  }
  const doc = await getDocument(src).promise
  const page = await doc.getPage(pg)
  const scale = 1;
  const viewport = page.getViewport({ scale });

  // divide 0.6 ratio!!! to get the actual page size
  // can optimise the transformation scale based on the viewport
  viewportWidth = viewport.width
  viewportHeight = viewport.height
  return page.getTextContent()

}


// reform the array for storing the contents and highlight information
function reformTextHighlightArray(dataPageArray: TextItem[]) {
  let transformArray = []
  var i: number = 0;
  while (i < dataPageArray.length) {

    // let curStrOfArray = dataPageArray[i]['str']
    let curSentOnRow = dataPageArray[i]['str']
    let iniHeight = dataPageArray[i]['transform'][5]
    let matchcount = 0
    let curSentWidth = dataPageArray[i]['width']


    var j = i + 1

    while (j < dataPageArray.length && matchcount < 1) {
      let nextHeight = dataPageArray[j]['transform'][5]
      let nextStrOfArray = dataPageArray[j]['str']
      let nextWidth = dataPageArray[j]['width']

      // concatnate the string into a sentence based on the same height
      if (nextHeight != iniHeight) {
        iniHeight = nextHeight
        matchcount++
      }

      if (matchcount < 1) {
        curSentOnRow = curSentOnRow + nextStrOfArray
        curSentWidth = curSentWidth + nextWidth
        j++
      }
    }

    if (curSentOnRow[0] != ' ') {
      transformArray.push({
        "org_i": i, "org_j": j, 'str': curSentOnRow, 'transformedLeft': dataPageArray[i]['transform'][4],
        "transformedTop": dataPageArray[i]['transform'][5], "transformedWidth": curSentWidth,
        "transformedHeight": dataPageArray[i]['height'], "single_c_wid": curSentWidth / curSentOnRow.length,
        "sentLen": curSentOnRow.length
      })
      i = j
    } else {
      i++
    }
  }
  return transformArray
}


// download json function definition
const downloadFile = async (fileName:string, records:any) => {
  const myData = records
  const json = JSON.stringify(myData);
  const blob = new Blob([json],{type:'application/json'});
  const href = await URL.createObjectURL(blob);
  const link = document.createElement('a');
  link.href = href;
  link.download = fileName + ".json";
  document.body.appendChild(link);
  link.click();
  document.body.removeChild(link);
}


// class definition for 
type ExperimentComp = {
  src: string;
  taskIDs: any[];
}

// pdf library loaded
const workerSrc = "https://unpkg.com/pdfjs-dist@2.8.335/build/pdf.worker.min.js"
const pdfIdx: string = 'pdfID'
const taskIDs: string = 'taskIDs'
const expTaskArray: any[] = []

let viewportWidth: number
let viewportHeight: number
let pageNum: number


for (const [key, value] of Object.entries(expList)) {
  let url = pdfList[expList[key][pdfIdx]]
  let taskStatus: any = {}
  for (const { "taskID": key1, "completed": status } of expList[key][taskIDs]) {
    taskStatus[key1] = status;
  }
  expTaskArray.push({
    expID: key,
    src: url,
    taskIDs: taskStatus,
  })
}


let arrPagesPro: any[] = []
let arrPages:any[] = []

expTaskArray.forEach(element => {
  // console.log(element)
  if (typeof workerSrc === "string") {
    GlobalWorkerOptions.workerSrc = workerSrc
  }
  let docxs = getDocument(element.src).promise
  arrPagesPro.push(docxs)
})

console.log(arrPagesPro)

await Promise.all(arrPagesPro.map(function (entity: any) {
    return entity;})).then(function (data: any) {
      arrPages = data
});


var promises: any[] = []

expTaskArray.forEach((element, index) => {
  var eachPDFpromises: any[] = []
  let expComp: ExperimentComp = {
    src: element.src,
    taskIDs: element.taskIDs
  }
  pageNum = 1
  let j: number = arrPages[index]["_pdfInfo"]["numPages"]
  while (pageNum <= j) {
    eachPDFpromises.push(getItems(expComp.src, pageNum))
    pageNum = pageNum + 1
  }
  promises.push(eachPDFpromises)
});


let dataPageArrayAll: any[] = []

await Promise.all(promises.map(function (entity: any) {
  return Promise.all(entity.map(function (item: any) {
    return item;
  }));
})).then(function (data) {
  dataPageArrayAll = data
});


let transformArrayAll:any=[]

dataPageArrayAll.forEach((elementArray: any, indexExp: any) => {
  let transformArray:any=[]
  elementArray.forEach((element: any, index: any) => {
    let items = element["items"]
    transformArray.push(reformTextHighlightArray(items))
  })
  transformArrayAll.push(transformArray)
})


// enable it if we want to save the raw data object generated by pdf highlight 
// const fileName1:string = "dataPageArrayAll"
// downloadFile(fileName1, dataPageArrayAll)

// save the data object generated of experiment and task json files
const fileName2:string = "expTaskArray"
downloadFile(fileName2, expTaskArray)

// save the sentence based object generated of experiment.json and task.json files
const fileName3:string = "transformArrayAll"
downloadFile(fileName3, transformArrayAll)
